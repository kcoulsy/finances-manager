---
description: Guidelines for creating and organizing server actions using next-safe-action
globs: src/features/**/actions/**/*.ts
alwaysApply: true
---

# Server Actions Guidelines

This project uses **next-safe-action** for type-safe Server Actions in Next.js App Router.

## File Structure

### Location
- **Always** place actions in `features/[feature-name]/actions/`
- File naming: `[action-name].action.ts`
- Example: `features/auth/actions/login.action.ts`

### Required Setup
Every action file must start with:

```typescript
"use server";

import { actionClient } from "@/features/shared/lib/actions/client";
import { [schema]Schema } from "../schemas/[feature].schema";
import { headers } from "next/headers"; // Only if needed for auth

export const [actionName]Action = actionClient
  .inputSchema([schema]Schema)
  .action(async ({ parsedInput }) => {
    // Implementation
  });
```

## Key Requirements

### 1. "use server" Directive
**Always** add `"use server"` at the top of action files:

```typescript
"use server";  // ← Required first line

import { actionClient } from "@/features/shared/lib/actions/client";
```

### 2. Schema Method
Use `.inputSchema()` (not `.schema()`):

```typescript
// ✅ Good
export const loginAction = actionClient
  .inputSchema(loginSchema)
  .action(async ({ parsedInput }) => {
    // ...
  });

// ❌ Bad
export const loginAction = actionClient
  .schema(loginSchema)  // Wrong method name
  .action(async ({ parsedInput }) => {
    // ...
  });
```

### 3. Error Handling
Always wrap server-side API calls in try/catch:

**CRITICAL: Error messages must be user-appropriate** since they are displayed in error toasts visible to end users. Never expose internal technical details, database errors, or stack traces to users.

```typescript
export const loginAction = actionClient
  .inputSchema(loginSchema)
  .action(async ({ parsedInput }) => {
    try {
      const response = await auth.api.signInEmail({
        body: {
          email: parsedInput.email,
          password: parsedInput.password,
        },
        headers: await headers(),
      });

      return {
        success: true,
        user: response.user,
      };
    } catch (error) {
      console.error("Login error:", error); // Log technical details for debugging
      // Always throw user-friendly messages
      throw new Error(
        error instanceof Error 
          ? error.message // Only if it's already user-friendly
          : "Failed to sign in. Please check your credentials and try again."
      );
    }
  });
```

**Good Error Messages (User-Appropriate):**
```typescript
// ✅ Good - Clear, actionable, user-friendly
throw new Error("Invalid email or password. Please try again.");
throw new Error("Contact not found.");
throw new Error("You don't have permission to perform this action.");
throw new Error("This email address is already registered.");

// ❌ Bad - Technical details, internal errors
throw new Error("PrismaClientKnownRequestError: P2002");
throw new Error("Database connection timeout");
throw new Error("Error: Validation failed at schema.validate()");
throw new Error("Cannot read property 'id' of undefined");
```

### 4. Headers Usage
When using `headers()` from `next/headers`:
- Only call it inside the action function (not at module level)
- Use `await headers()` when passing to better-auth APIs
- Only import if actually needed

```typescript
// ✅ Good
import { headers } from "next/headers";

export const loginAction = actionClient
  .inputSchema(loginSchema)
  .action(async ({ parsedInput }) => {
    const response = await auth.api.signInEmail({
      body: { email: parsedInput.email, password: parsedInput.password },
      headers: await headers(),  // Called inside action
    });
  });

// ❌ Bad - Don't call at module level
import { headers } from "next/headers";
const headersInstance = await headers();  // This will fail!
```

### 5. Schema Location
- Feature-specific schemas: `features/[feature-name]/schemas/`
- Import path: `../schemas/[feature].schema.ts`

```typescript
// ✅ Good
import { loginSchema } from "../schemas/auth.schema";

// ❌ Bad - Don't import from shared unless truly shared
import { loginSchema } from "@/features/shared/lib/validations/auth.schema";
```

## Action Patterns

### Authentication Actions
For actions that require authentication, check session first:

```typescript
export const changePasswordAction = actionClient
  .inputSchema(changePasswordSchema)
  .action(async ({ parsedInput }) => {
    const session = await getSession();

    if (!session) {
      throw new Error("You must be signed in to change your password.");
    }

    // Rest of implementation
  });
```

### Database Actions
When working with Prisma, use the shared client:

```typescript
import { db } from "@/features/shared/lib/db/client";

export const getUserAction = actionClient
  .inputSchema(getUserSchema)
  .action(async ({ parsedInput }) => {
    try {
      const user = await db.user.findUnique({
        where: { id: parsedInput.userId },
      });
      
      if (!user) {
        throw new Error("User not found.");
      }

      return { user };
    } catch (error) {
      console.error("Get user error:", error); // Log technical details
      
      // Provide user-friendly error messages
      if (error instanceof Error && error.message === "User not found.") {
        throw error; // Already user-friendly
      }
      
      throw new Error("Unable to retrieve user information. Please try again.");
    }
  });
```

### Better-Auth API Calls
Better-auth API methods return data directly (not wrapped in `data`):

```typescript
// ✅ Good - Response has user directly
const response = await auth.api.signInEmail({
  body: { email, password },
  headers: await headers(),
});

return {
  success: true,
  user: response.user,  // Direct access
};

// ❌ Bad - Don't use response.data.user
return {
  success: true,
  user: response.data.user,  // Wrong - data doesn't exist
};
```

## Client Component Usage

Actions are called from client components:

```typescript
"use client";

import { loginAction } from "@/features/auth/actions/login.action";

export function LoginForm() {
  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    const formData = new FormData(e.currentTarget);
    
    const result = await loginAction({
      email: formData.get("email") as string,
      password: formData.get("password") as string,
    });

    // Handle result
    if (result?.serverError) {
      // Handle error
    }

    if (result?.data?.success) {
      // Handle success
    }
  };
}
```

## Return Values

### Success Response
Always return a consistent structure:

```typescript
return {
  success: true,
  message?: string,  // Optional success message
  data?: any,        // Optional data
};
```

### Error Handling
- Use try/catch for all async operations
- Log errors for debugging (console.error with technical details)
- **Always throw user-appropriate error messages** - these messages are displayed in error toasts to users
- Never expose technical details, database error codes, stack traces, or internal system information

```typescript
try {
  // Operation
  return { success: true, data };
} catch (error) {
  console.error("Action error:", error); // Log technical details for debugging
  
  // Provide user-friendly error messages
  if (error instanceof Error) {
    // Only use the error message if it's already user-friendly
    // For known errors, provide specific user messages
    if (error.message.includes("not found")) {
      throw new Error("The requested item could not be found.");
    }
    if (error.message.includes("permission") || error.message.includes("unauthorized")) {
      throw new Error("You don't have permission to perform this action.");
    }
    // For unexpected errors, use generic but helpful messages
    throw new Error("Something went wrong. Please try again later.");
  }
  
  throw new Error("An unexpected error occurred. Please try again.");
}
```

## Best Practices

1. **Keep actions focused**: One action per file, one responsibility
2. **Validate input**: Always use Zod schemas
3. **Handle errors gracefully**: Always wrap in try/catch
4. **Log errors**: Use console.error for debugging (technical details)
5. **User-friendly error messages**: Always throw error messages that are appropriate for end users - these messages are displayed in error toasts
6. **Never expose technical details**: Don't show database error codes, stack traces, internal system messages, or technical jargon to users
7. **Type safety**: Let TypeScript infer types from schemas
8. **Server-only**: Never import client-side code in actions
9. **Consistent naming**: Use descriptive action names ending with "Action"

## Middleware and Toast Notifications

This project includes middleware for automatic error handling and toast notifications using Sonner.

### Error Handling Middleware (Automatic)

The error handling middleware is automatically applied to all actions via `actionClient`. When an action throws an error, it's automatically caught and formatted. The error message is available in `result.serverError` on the client side.

### Returning Toast Details from Actions

Actions can return toast configuration in their return value:

```typescript
"use server";

import { actionClient } from "@/features/shared/lib/actions/client";

export const createItemAction = actionClient
  .inputSchema(createItemSchema)
  .action(async ({ parsedInput }) => {
    // ... create item logic ...

    return {
      success: true,
      item: newItem,
      toast: {
        message: "Item created successfully",
        type: "success",
        description: `Item "${newItem.name}" has been created`,
        duration: 3000, // optional
      },
    };
  });
```

### Toast Configuration

```typescript
type ToastConfig = {
  message: string;                    // Required: Toast message
  type?: "success" | "error" | "info" | "warning"; // Optional: Toast type (default: "success")
  description?: string;                // Optional: Additional description
  duration?: number;                  // Optional: Duration in milliseconds
};
```

### Client-Side Usage

#### Option 1: Using `useActionWithToast` (Recommended)

This is the recommended approach using next-safe-action's built-in `useAction` hook with callbacks. It provides automatic toast handling and better integration with the framework.

```typescript
"use client";

import { useActionWithToast } from "@/features/shared/lib/actions/use-action-with-toast";
import { createItemAction } from "../actions/create-item.action";
import type { CreateItemInput } from "../schemas/item.schema";

export function CreateItemForm() {
  // Automatically handles toasts via onSuccess/onError callbacks
  const { execute, status, result } = useActionWithToast(createItemAction);

  const handleSubmit = async (data: CreateItemInput) => {
    await execute(data);
    // Toasts are automatically shown via callbacks
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      {/* Form fields */}
      <button type="submit" disabled={status === "executing"}>
        {status === "executing" ? "Creating..." : "Create Item"}
      </button>
    </form>
  );
}
```

With custom toast messages:

```typescript
"use client";

import { useActionWithToast } from "@/features/shared/lib/actions/use-action-with-toast";
import { createItemAction } from "../actions/create-item.action";

export function CreateItemForm() {
  const { execute, status } = useActionWithToast(createItemAction, {
    successToast: {
      message: "Item created successfully!",
      type: "success",
      description: "Your item has been created.",
    },
    errorToast: {
      message: "Failed to create item",
      type: "error",
    },
  });

  // Or disable toasts entirely
  const { execute, status } = useActionWithToast(createItemAction, {
    showToasts: false, // No automatic toasts
  });
}
```

Using next-safe-action's `useAction` directly with callbacks:

```typescript
"use client";

import { useAction } from "next-safe-action/hooks";
import { showToastFromAction } from "@/features/shared/lib/actions/toast";
import { toast } from "sonner";
import { createItemAction } from "../actions/create-item.action";

export function CreateItemForm() {
  const { execute, status } = useAction(createItemAction, {
    onSuccess: ({ data }) => {
      // Show toast from action result
      showToastFromAction({ data });
      
      // Or custom logic
      toast.success("Item created!");
    },
    onError: ({ error }) => {
      // error is an object with serverError property
      // Show error toast (error object is compatible with ActionResult)
      showToastFromAction(error);
      
      // Or access serverError directly
      if (error.serverError) {
        toast.error(error.serverError);
      }
    },
  });

  // ...
}
```

#### Option 2: Using the utility function

```typescript
"use client";

import { handleActionWithToast } from "@/features/shared/lib/actions/toast";
import { createItemAction } from "../actions/create-item.action";

export function CreateItemForm() {
  const handleSubmit = async (data: CreateItemInput) => {
    const result = await createItemAction(data);
    
    // Automatically shows toast if there's an error or toast config in result
    handleActionWithToast(result);
    
    // Or provide a custom toast
    handleActionWithToast(result, {
      message: "Custom success message",
      type: "success",
    });
  };
}
```

#### Option 3: Manual handling

```typescript
"use client";

import { showToastFromAction } from "@/features/shared/lib/actions/toast";
import { createItemAction } from "../actions/create-item.action";

export function CreateItemForm() {
  const handleSubmit = async (data: CreateItemInput) => {
    const result = await createItemAction(data);
    
    // Show toast from result (handles both errors and success toasts)
    showToastFromAction(result);
    
    // Handle the result
    if (result?.serverError) {
      // Error toast was already shown
      return;
    }
    
    if (result?.data?.success) {
      // Success toast was shown if configured in action
    }
  };
}
```

### Error Handling with Toasts

Errors are automatically caught by the middleware and made available in `result.serverError`. The client-side utilities automatically show error toasts for server errors.

**IMPORTANT: Error messages thrown in actions are displayed directly to users in error toasts.** Always ensure error messages are:
- User-friendly and clear
- Actionable when possible
- Free of technical jargon
- Appropriate for end users

```typescript
// ✅ Good - User-friendly error message
export const someAction = actionClient
  .inputSchema(someSchema)
  .action(async ({ parsedInput }) => {
    if (!condition) {
      throw new Error("Unable to complete this action. Please check your input and try again.");
    }
    return { success: true };
  });

// ❌ Bad - Technical error message shown to users
export const someAction = actionClient
  .inputSchema(someSchema)
  .action(async ({ parsedInput }) => {
    if (!condition) {
      throw new Error("PrismaClientValidationError: Validation failed"); // Too technical!
    }
    return { success: true };
  });

// On client - error toast is shown automatically
const result = await someAction(data);
// If error occurred, result.serverError contains the message
// and showToastFromAction will display it automatically
handleActionWithToast(result);
```

### Middleware Files

- `src/features/shared/lib/actions/middleware.ts` - Error handling middleware
- `src/features/shared/lib/actions/toast.ts` - Toast utility functions
- `src/features/shared/lib/actions/use-action-with-toast.ts` - React hook using next-safe-action's `useAction` with callbacks (Recommended)
- `src/features/shared/lib/actions/use-action-toast.ts` - Legacy hook for backwards compatibility

### Reference

For more information on next-safe-action hooks and callbacks, see:
- [next-safe-action hook callbacks documentation](https://next-safe-action.dev/docs/execute-actions/hooks/hook-callbacks)
